# Merge with the dataset by surv, as that tells which the chance of being censored in each death
t <- merge(xf,sct,by.x="surv", by.y="sc.time", all.x=T)
# Calculating Band and Tsiatis cost estimator
BT <- mean((t$cost*t$delta)/t$sc.surv, na.rm=T)
#################################################################
##                          section 6:                         ##
##                Zhao and Tian's method (2001)                ##
#################################################################
# Opposite Kaplain Meier - chance of censoring - for each period (cummulative)
sb <- summary(survfit(Surv(xf$surv,
xf$delta == 0) ~ 1),
times = (xf$surv))
#times = t_data$surv[t_data$delta %in% c(0,1)])
# new dataframe with values from the list and only unique so that we can merge them
sbt <- data.frame(sb$time, sb$surv)
# adjust for last proparbility = 0 (why we do this i'm not sure)
sbt$sb.surv[sbt$sb.surv == 0] <- min(sbt$sb.surv[sbt$sb.surv != 0])
# remove non unique to avoid errors when merging
sbt <- unique(sbt)
# Merge with the dataset by surv, as that tells which the chance of being censored in each death
e <- merge(x,sbt,by.x="surv", by.y="sb.time", all.x=T)
# Forward loop to calculate mean cost of patients with longer survival than patient i at patient i's surv
e$mcostlsurv <- NA
for(i in 1:nrow(e)){
# temp set for longer survival than i
t_data2 <- subset(x, start < e$surv[i])
# Calculating the cost running costs of split periods
t_data2$ncost <- ifelse(t_data2$stop> e$surv[i], (t_data2$cost/(t_data2$stop-t_data2$start))*(e$surv[i]-t_data2$start),0)
# Don't double include split costs
t_data2$cost <- ifelse(t_data2$stop > e$surv[i],0,t_data2$cost)
# Now added to the other costs
t_data2$cost <- t_data2$cost + t_data2$ncost
# summarized
t_data_total_temp <- t_data2 %>%
group_by(id) %>%
summarize(cost = sum(cost, na.rm=T),
surv= first(surv))
# calculating the individual mean costs of everyone who lives longer
e$mcostlsurv[i] <- mean(t_data_total_temp$cost[t_data_total_temp$surv >= e$surv[i]])
}
rm(i)
# Summarizing the dataset
ee <- e %>%
group_by(id) %>%
summarize(cost = sum(cost, na.rm=T),
delta = first(delta),
sb.surv= first(sb.surv),
surv= first(surv),
mcostlsurv = mean(mcostlsurv, na.rm=T))
# The ZT estimator of mean costs
ZT <- mean((ee$delta * (ee$cost / ee$sb.surv)) + ((1-ee$delta) * ((ee$cost-ee$mcostlsurv) / ee$sb.surv)), na.rm=T)
ZT
#################################################################
##                          section 6:                         ##
##                                                             ##
#################################################################
results <- list("These results should be checked before ...",
data.frame(full_sample,
complete_case,
LinT,
BT,
ZT))
return(results)
}
ccmean(df_censored)
ccmean <- function(x, id="id", cost="cost", start="start", stop="stop", delta="delta", surv="surv") {
# Ordering the dataset
x <- x[order(x$id, x$delta),]
row.names(x) <- 1:nrow(x)
# Some calculations don't use cost history and therefore collapse by ID
xf <- x %>%
group_by(id) %>%
summarize(cost = sum(cost, na.rm=T),
delta = last(delta),
surv = first(surv))
#################################################################
##                          section 1:                         ##
##                   Naive (Avaiable Sample)                   ##
#################################################################
# Costs are summed and a mean are found
available_sample <- xf %>%
group_by(id) %>%
mutate(sumcost = sum(cost, na.rm=T)) %>%
ungroup() %>%
summarize(m = mean(sumcost, na.rm=T)) %>%
as.numeric()
#################################################################
##                          section 2:                         ##
##                    Naive (complete case)                    ##
#################################################################
# Restricted to only full cases where the patient dies before 1461
b <- subset(xf, xf$delta == 1)
# Costs are summed up and calculated mean
complete_case <- b %>%
group_by(id) %>%
mutate(sumcost = sum(cost, na.rm=T)) %>%
ungroup() %>%
summarize(m = mean(sumcost, na.rm=T)) %>%
as.numeric()
#################################################################
##                          section 4:                         ##
##                     Lin's method (1997)                     ##
#################################################################
# a calculation of chance of survival for each interval (cummulative) (interval = censoring)
sv <- summary(survfit(Surv(xf$surv, xf$delta == 1) ~ 1))
# calculate average costs of patients deceased within each interval
a <- subset(xf, delta == 1) %>%
mutate(ints = cut(surv, breaks = c(sv$time))) %>%
group_by(ints) %>%
summarise(mean = mean(cost))
# calculate chance of death within each interval
dif <- c(diff(sv$surv, lag= 1), rep(NA,1))*-1
# Gathering the data in a new dataframe
d <- data.frame(sv$time, sv$surv, dif, a)
rm(dif)
# calculating Lin's T estimate of total costs
LinT <- sum(d$dif*d$mean, na.rm=T) + (tail(d$sv.surv, n=1)*tail(d$mean, n=1))
#################################################################
##                          section 5:                         ##
##               Bang and Tsiatis's method (2000)              ##
#################################################################
# Opposite Kaplain Meier - chance of censoring - for each period (cummulative)
sc <- summary(survfit(Surv(xf$surv, xf$delta == 0) ~ 1),
times = xf$surv[xf$delta == 1])
# Save changes of censoring and time in seperate dataframe
sct <- data.frame(sc$time, sc$surv)
# Merge with the dataset by surv, as that tells which the chance of being censored in each death
t <- merge(xf,sct,by.x="surv", by.y="sc.time", all.x=T)
# Calculating Band and Tsiatis cost estimator
BT <- mean((t$cost*t$delta)/t$sc.surv, na.rm=T)
#################################################################
##                          section 6:                         ##
##                Zhao and Tian's method (2001)                ##
#################################################################
# Opposite Kaplain Meier - chance of censoring - for each period (cummulative)
sb <- summary(survfit(Surv(xf$surv,
xf$delta == 0) ~ 1),
times = (xf$surv))
#times = t_data$surv[t_data$delta %in% c(0,1)])
# new dataframe with values from the list and only unique so that we can merge them
sbt <- data.frame(sb$time, sb$surv)
# adjust for last proparbility = 0 (why we do this i'm not sure)
sbt$sb.surv[sbt$sb.surv == 0] <- min(sbt$sb.surv[sbt$sb.surv != 0])
# remove non unique to avoid errors when merging
sbt <- unique(sbt)
# Merge with the dataset by surv, as that tells which the chance of being censored in each death
e <- merge(x,sbt,by.x="surv", by.y="sb.time", all.x=T)
# Forward loop to calculate mean cost of patients with longer survival than patient i at patient i's surv
e$mcostlsurv <- NA
for(i in 1:nrow(e)){
# temp set for longer survival than i
t_data2 <- subset(x, start < e$surv[i])
# Calculating the cost running costs of split periods
t_data2$ncost <- ifelse(t_data2$stop> e$surv[i], (t_data2$cost/(t_data2$stop-t_data2$start))*(e$surv[i]-t_data2$start),0)
# Don't double include split costs
t_data2$cost <- ifelse(t_data2$stop > e$surv[i],0,t_data2$cost)
# Now added to the other costs
t_data2$cost <- t_data2$cost + t_data2$ncost
# summarized
t_data_total_temp <- t_data2 %>%
group_by(id) %>%
summarize(cost = sum(cost, na.rm=T),
surv= first(surv))
# calculating the individual mean costs of everyone who lives longer
e$mcostlsurv[i] <- mean(t_data_total_temp$cost[t_data_total_temp$surv >= e$surv[i]])
}
rm(i)
# Summarizing the dataset
ee <- e %>%
group_by(id) %>%
summarize(cost = sum(cost, na.rm=T),
delta = first(delta),
sb.surv= first(sb.surv),
surv= first(surv),
mcostlsurv = mean(mcostlsurv, na.rm=T))
# The ZT estimator of mean costs
ZT <- mean((ee$delta * (ee$cost / ee$sb.surv)) + ((1-ee$delta) * ((ee$cost-ee$mcostlsurv) / ee$sb.surv)), na.rm=T)
ZT
#################################################################
##                          section 6:                         ##
##                                                             ##
#################################################################
results <- list("These results should be checked before ...",
data.frame(available_sample,
complete_case,
LinT,
BT,
ZT))
return(results)
}
ccmean(df_censored)
ccmean <- function(x, id="id", cost="cost", start="start", stop="stop", delta="delta", surv="surv") {
# Ordering the dataset
x <- x[order(x$id, x$delta),]
row.names(x) <- 1:nrow(x)
# Some calculations don't use cost history and therefore collapse by ID
xf <- x %>%
group_by(id) %>%
summarize(cost = sum(cost, na.rm=T),
delta = last(delta),
surv = first(surv))
#################################################################
##                          section 1:                         ##
##                   Naive (Avaiable Sample)                   ##
#################################################################
# Costs are summed and a mean are found
available_sample <- xf %>%
group_by(id) %>%
mutate(sumcost = sum(cost, na.rm=T)) %>%
ungroup() %>%
summarize(m = mean(sumcost, na.rm=T)) %>%
as.numeric()
#################################################################
##                          section 2:                         ##
##                    Naive (complete case)                    ##
#################################################################
# Restricted to only full cases where the patient dies before 1461
b <- subset(xf, xf$delta == 1)
# Costs are summed up and calculated mean
complete_case <- b %>%
group_by(id) %>%
mutate(sumcost = sum(cost, na.rm=T)) %>%
ungroup() %>%
summarize(m = mean(sumcost, na.rm=T)) %>%
as.numeric()
#################################################################
##                          section 4:                         ##
##                     Lin's method (1997)                     ##
#################################################################
# a calculation of chance of survival for each interval (cummulative) (interval = censoring)
sv <- summary(survfit(Surv(xf$surv, xf$delta == 1) ~ 1))
# calculate average costs of patients deceased within each interval
a <- subset(xf, delta == 1) %>%
mutate(ints = cut(surv, breaks = c(sv$time))) %>%
group_by(ints) %>%
summarise(mean = mean(cost))
# calculate chance of death within each interval
dif <- c(diff(sv$surv, lag= 1), rep(NA,1))*-1
# Gathering the data in a new dataframe
d <- data.frame(sv$time, sv$surv, dif, a)
rm(dif)
# calculating Lin's T estimate of total costs
LinT <- sum(d$dif*d$mean, na.rm=T) + (tail(d$sv.surv, n=1)*tail(d$mean, n=1))
#################################################################
##                          section 5:                         ##
##               Bang and Tsiatis's method (2000)              ##
#################################################################
# Opposite Kaplain Meier - chance of censoring - for each period (cummulative)
sc <- summary(survfit(Surv(xf$surv, xf$delta == 0) ~ 1),
times = xf$surv)
# Save changes of censoring and time in seperate dataframe
sct <- data.frame(sc$time, sc$surv)
# adjust for last proparbility = 0 (why we do this i'm not sure)
sct$sc.surv[sct$sc.surv == 0] <- min(sct$sc.surv[sct$sc.surv != 0])
# remove non unique to avoid errors when merging
sct <- unique(sct)
# Merge with the dataset by surv, as that tells which the chance of being censored in each death
t <- merge(xf,sct,by.x="surv", by.y="sc.time", all.x=T)
# Calculating Band and Tsiatis cost estimator
BT <- mean((t$cost*t$delta)/t$sc.surv)
#################################################################
##                          section 6:                         ##
##                Zhao and Tian's method (2001)                ##
#################################################################
# Opposite Kaplain Meier - chance of censoring - for each period (cummulative)
sb <- summary(survfit(Surv(xf$surv,
xf$delta == 0) ~ 1),
times = (xf$surv))
#times = t_data$surv[t_data$delta %in% c(0,1)])
# new dataframe with values from the list and only unique so that we can merge them
sbt <- data.frame(sb$time, sb$surv)
# adjust for last proparbility = 0 (why we do this i'm not sure)
sbt$sb.surv[sbt$sb.surv == 0] <- min(sbt$sb.surv[sbt$sb.surv != 0])
# remove non unique to avoid errors when merging
sbt <- unique(sbt)
# Merge with the dataset by surv, as that tells which the chance of being censored in each death
e <- merge(x,sbt,by.x="surv", by.y="sb.time", all.x=T)
# Forward loop to calculate mean cost of patients with longer survival than patient i at patient i's surv
e$mcostlsurv <- NA
for(i in 1:nrow(e)){
# temp set for longer survival than i
t_data2 <- subset(x, start < e$surv[i])
# Calculating the cost running costs of split periods
t_data2$ncost <- ifelse(t_data2$stop> e$surv[i], (t_data2$cost/(t_data2$stop-t_data2$start))*(e$surv[i]-t_data2$start),0)
# Don't double include split costs
t_data2$cost <- ifelse(t_data2$stop > e$surv[i],0,t_data2$cost)
# Now added to the other costs
t_data2$cost <- t_data2$cost + t_data2$ncost
# summarized
t_data_total_temp <- t_data2 %>%
group_by(id) %>%
summarize(cost = sum(cost, na.rm=T),
surv= first(surv))
# calculating the individual mean costs of everyone who lives longer
e$mcostlsurv[i] <- mean(t_data_total_temp$cost[t_data_total_temp$surv >= e$surv[i]])
}
rm(i)
# Summarizing the dataset
ee <- e %>%
group_by(id) %>%
summarize(cost = sum(cost, na.rm=T),
delta = first(delta),
sb.surv= first(sb.surv),
surv= first(surv),
mcostlsurv = mean(mcostlsurv, na.rm=T))
# The ZT estimator of mean costs
ZT <- mean((ee$delta * (ee$cost / ee$sb.surv)) + ((1-ee$delta) * ((ee$cost-ee$mcostlsurv) / ee$sb.surv)), na.rm=T)
ZT
#################################################################
##                          section 6:                         ##
##                                                             ##
#################################################################
results <- list("These results should be checked before ...",
data.frame(available_sample,
complete_case,
LinT,
BT,
ZT))
return(results)
}
ccmean(df_censored)
devtools::install_github("HaemAalborg/ccostr")
library(cencost)
library(cencost)
i        <- LETTERS[seq( from = 1, to = 26 )]
id       <- rep(i, sample(5:20, size=26, replace=T))
start    <- sample(1:2000, size=length(id), replace=T)
stop     <- start + sample(1:100, size=length(id), replace=T)
stop     <- ifelse(stop>2000, 2000, stop)
cost     <- sample(1:10000, size=length(id), replace=T)
surv     <- tapply(stop, id, max)
censor   <- sample(1500:2500, size=26, replace=T)
delta    <- ifelse(surv <= censor, 1,0)
df_1             <- data.frame(i,censor, delta, surv)
df_2             <- data.frame(id, start, stop, cost)
df_full          <- merge(df_2, df_1, by.x="id", by.y="i")
df_censored      <- subset(df_full, stop <= censor)
rm(cost, id, start, stop, delta, censor, i, surv, df_1, df_2)
true_mean <- df_censored %>%
group_by(id) %>%
mutate(cost = sum(cost, na.rm=T)) %>%
ungroup() %>%
summarize(m = mean(cost, na.rm=T)) %>%
as.numeric()
df_censored <- df_censored[order(df_censored$id, df_censored$delta, df_censored$start),]
row.names(df_censored) <- 1:nrow(df_censored)
# Some calculations don't use cost history and therefore collapse by ID
df_censored <- as_tibble(df_censored)
df_censored_total <- as_tibble(df_censored) %>%
group_by(id) %>%
summarize(tcost = sum(cost),
delta = last(delta),
surv= first(surv))
ccmean(df_censored)
i        <- LETTERS[seq( from = 1, to = 26 )]
id       <- rep(i, sample(5:20, size=26, replace=T))
start    <- sample(1:2000, size=length(id), replace=T)
stop     <- start + sample(1:100, size=length(id), replace=T)
stop     <- ifelse(stop>2000, 2000, stop)
cost     <- sample(1:10000, size=length(id), replace=T)
surv     <- tapply(stop, id, max)
censor   <- sample(1500:2500, size=26, replace=T)
delta    <- ifelse(surv <= censor, 1,0)
df_1             <- data.frame(i,censor, delta, surv)
df_2             <- data.frame(id, start, stop, cost)
df_full          <- merge(df_2, df_1, by.x="id", by.y="i")
df_censored      <- subset(df_full, stop <= censor)
rm(cost, id, start, stop, delta, censor, i, surv, df_1, df_2)
true_mean <- df_censored %>%
group_by(id) %>%
mutate(cost = sum(cost, na.rm=T)) %>%
ungroup() %>%
summarize(m = mean(cost, na.rm=T)) %>%
as.numeric()
df_censored <- df_censored[order(df_censored$id, df_censored$delta, df_censored$start),]
row.names(df_censored) <- 1:nrow(df_censored)
# Some calculations don't use cost history and therefore collapse by ID
df_censored <- as_tibble(df_censored)
df_censored_total <- as_tibble(df_censored) %>%
group_by(id) %>%
summarize(tcost = sum(cost),
delta = last(delta),
surv= first(surv))
ccmean(df_censored)
ccmean(df_full)
View(df_full)
document("C:\Users\upc6\Documents\GitHub\ccostr")
document("\Users\upc6\Documents\GitHub\ccostr")
library(devtools)
document("C:\Users\upc6\Documents\GitHub\ccostr")
setwd("~/GitHub/ccostr")
devtools::document()
devtools::install_github("HaemAalborg/ccostr")
library(ccostr)
library(survival)
library(dplyr)
ccmean(df_0)
library(ccostr)
library(survival)
library(dplyr)
ccmean(df_1)
id      <- c("A", "A", "A", "B" ,"C", "C")
start   <- c(1,30,88,18,1,67)
stop    <- c(1,82,88,198,5,88)
cost    <- c(550,1949,45,4245,23,567)
delta   <- c(0,0,0,0,1,1)
surv    <- c(343,343,343,903,445,445)
df_1 <- data.frame(id, start,stop,cost,delta,surv)
print(df_1, row.names=FALSE)
library(ccostr)
library(survival)
library(dplyr)
ccmean(df_1)
View(df_full)
ccmean(df_censored)
sqrt(776)
sqrt(2000)
sqrt(100)
sqrt(10)
sqrt(-10)
sqrt(1400)
sqrt(sqrt(1400))
sqrt(sqrt(200))
sqrt(sqrt(20))
sqrt(sqrt(800))
sqrt(sqrt(600*1900))
sqrt(sqrt(100*1900))
sqrt(sqrt(1900*1900))
sqrt(sqrt(190*190))
1900/600
df_1             <- data.frame(i,censor, delta, surv)
df_2             <- data.frame(id, start, stop, cost)
i        <- LETTERS[seq( from = 1, to = 26 )]
id       <- rep(i, sample(5:20, size=26, replace=T))
start    <- sample(1:2000, size=length(id), replace=T)
stop     <- start + sample(1:100, size=length(id), replace=T)
stop     <- ifelse(stop>2000, 2000, stop)
cost     <- sample(1:10000, size=length(id), replace=T)
surv     <- tapply(stop, id, max)
censor   <- sample(1500:2500, size=26, replace=T)
delta    <- ifelse(surv <= censor, 1,0)
df_1             <- data.frame(i,censor, delta, surv)
df_2             <- data.frame(id, start, stop, cost)
df_full          <- merge(df_2, df_1, by.x="id", by.y="i")
df_full$adj_cost <- df_full$surv
df_censored      <- subset(df_full, stop <= censor)
i        <- LETTERS[seq( from = 1, to = 26 )]
id       <- rep(i, sample(5:20, size=26, replace=T))
start    <- sample(1:2000, size=length(id), replace=T)
stop     <- start + sample(1:100, size=length(id), replace=T)
stop     <- ifelse(stop>2000, 2000, stop)
cost     <- sample(1:10000, size=length(id), replace=T)
surv     <- as.vector(tapply(stop, id, max))
censor   <- sample(1500:2500, size=26, replace=T)
delta    <- ifelse(surv <= censor, 1,0)
df_1             <- data.frame(i,censor, delta, surv)
df_2             <- data.frame(id, start, stop, cost)
df_full          <- merge(df_2, df_1, by.x="id", by.y="i")
df_full$adj_cost <- df_full$censor/df_full$start
df_full$adj_cost <- df_full$cost/(df_full$censor/df_full$start)
############################################################################
############################################################################
###                                                                      ###
###                                TITLE:                                ###
###                 SIMULATING SURVIVAL DATA WITH COSTS                  ###
###                                                                      ###
############################################################################
############################################################################
i        <- LETTERS[seq( from = 1, to = 26 )]
id       <- rep(i, sample(5:20, size=26, replace=T))
start    <- sample(1:2000, size=length(id), replace=T)
stop     <- start + sample(1:100, size=length(id), replace=T)
stop     <- ifelse(stop>2000, 2000, stop)
cost     <- sample(1:10000, size=length(id), replace=T)
surv     <- as.vector(tapply(stop, id, max))
censor   <- sample(1500:2500, size=26, replace=T)
delta    <- ifelse(surv <= censor, 1,0)
df_1             <- data.frame(i,censor, delta, surv)
df_2             <- data.frame(id, start, stop, cost)
df_full          <- merge(df_2, df_1, by.x="id", by.y="i")
df_full$adj_cost <- df_full$cost/(df_full$censor/df_full$start)
df_censored      <- subset(df_full, stop <= censor)
rm(cost, id, start, stop, delta, censor, i, surv)
true_mean <- df_censored %>%
group_by(id) %>%
mutate(cost = sum(cost, na.rm=T)) %>%
ungroup() %>%
summarize(m = mean(cost, na.rm=T)) %>%
as.numeric()
true_mean_adj <- df_censored %>%
group_by(id) %>%
mutate(adj_cost = sum(cost, na.rm=T)) %>%
ungroup() %>%
summarize(m = mean(cost, na.rm=T)) %>%
as.numeric()
ccmean(df_censored)
ccmean(df_censored, cost="adj_cost")
df_full$cost <- df_full$cost/(df_full$censor/df_full$start)
df_censored      <- subset(df_full, stop <= censor)
ccmean(df_censored)
true_mean <- df_censored %>%
group_by(id) %>%
mutate(cost = sum(cost, na.rm=T)) %>%
ungroup() %>%
summarize(m = mean(cost, na.rm=T)) %>%
as.numeric()
library(ggfortify)
library(survival)
fit <- survfit(Surv(surv, delta) ~ 1, data = df_full)
autoplot(fit)
fit <- survfit(Surv(surv, delta) ~ 1, data = df_censored)
autoplot(fit)
